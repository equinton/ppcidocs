[
  {
    "objectID": "legal_notice.html",
    "href": "legal_notice.html",
    "title": "PPCI - PrototypePHP for CodeIgniter",
    "section": "",
    "text": "Nom du site : \nURL complète du site :"
  },
  {
    "objectID": "legal_notice.html#identification-du-site",
    "href": "legal_notice.html#identification-du-site",
    "title": "PPCI - PrototypePHP for CodeIgniter",
    "section": "",
    "text": "Nom du site : \nURL complète du site :"
  },
  {
    "objectID": "legal_notice.html#éditeurs-du-site",
    "href": "legal_notice.html#éditeurs-du-site",
    "title": "PPCI - PrototypePHP for CodeIgniter",
    "section": "Éditeur(s) du site",
    "text": "Éditeur(s) du site\nINRAE - Institut national de recherche pour l’agriculture, l’alimentation et l’environnement INRAE est un établissement public à caractère scientifique et technologique. Il a son siège au 147, rue de l’université – 75338 Paris cedex 07. Ses statuts sont publiés dans le code rural et de la pêche maritime (articles R831-1 et suivants).\nIl est représenté par son Président Directeur général, M. Philippe MAUGUIN. Contact mail: web@inrae.fr - contact téléphonique: 01 42 75 90 00"
  },
  {
    "objectID": "legal_notice.html#numéros-didentification",
    "href": "legal_notice.html#numéros-didentification",
    "title": "PPCI - PrototypePHP for CodeIgniter",
    "section": "Numéros d’identification",
    "text": "Numéros d’identification\nINRAE SIREN: 180070039 Code APE: 7219Z Numéro de TVA intracommunautaire: FR 57 1800700039"
  },
  {
    "objectID": "legal_notice.html#publication-du-site",
    "href": "legal_notice.html#publication-du-site",
    "title": "PPCI - PrototypePHP for CodeIgniter",
    "section": "Publication du site",
    "text": "Publication du site\nNom du directeur de publication : M. Philippe MAUGUIN Nom du responsable de rédaction : xxxxx Webmaster du site : xxx"
  },
  {
    "objectID": "legal_notice.html#hébergeur-du-site",
    "href": "legal_notice.html#hébergeur-du-site",
    "title": "PPCI - PrototypePHP for CodeIgniter",
    "section": "Hébergeur du site",
    "text": "Hébergeur du site\nINRAE Établissement public à caractère scientifique et technologique 147, rue de l’université – 75338 Paris cedex 07 01 42 75 90 00"
  },
  {
    "objectID": "news.html",
    "href": "news.html",
    "title": "Events",
    "section": "",
    "text": "Newsletter #1\n\n\n\n\n\n\nFirst name, Last name\n\n\n11 mars 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNewsletter #2\n\n\n\n\n\n\nFirst name, Last name\n\n\n12 mars 2024\n\n\n\n\n\n\n\n\nAucun article correspondant"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "PPCI - PrototypePHP for CodeIgniter",
    "section": "",
    "text": "Test de contenu français\n\n\n\n\n\n\n\n\n\n\n\nDate\n\n\nTitre\n\n\nAuteur·rice\n\n\n\n\n\n\n\n\n\n11 mars 2024\n\n\nNewsletter #1\n\n\nFirst name, Last name\n\n\n\n\n\n\n\n12 mars 2024\n\n\nNewsletter #2\n\n\nFirst name, Last name\n\n\n\n\n\nAucun article correspondant"
  },
  {
    "objectID": "views.html",
    "href": "views.html",
    "title": "Les vues",
    "section": "",
    "text": "Les vues\nL’envoi d’informations au navigateur fait appel à des vues, chacune étant dédiée à un type d’informations (pages web, fichiers pdf, requêtes Ajax, fichiers binaires, etc.). Elles sont disponibles sous forme de services (décrits dans ppci/Config/Services.php), et sont physiquement stockées dans Ppci/Libraries/Views.\nToutes les vues héritent de la classe Ppci\\Libraries\\Views\\DefaultView, qui comprend les fonctions génériques suivantes :\n\nfunction set($value, $variable = \"\") : affecte un contenu (nommé ou non, si variable est renseigné) à la vue\nfunction get($variable = \"\") : récupère le contenu d’une variable ou le contenu affecté\nfunction encodehtml($data) : fonction récursive d’encodage en HTML des variables\nfunction send($param = \"\") : déclenche l’envoi des informations. Cette fonction est systématiquement réécrite dans chaque vue.\n\n\nAffichage des pages\n$view = service (\"Smarty\");\nLes pages web sont générées avec le moteur de templates Smarty. Les modèles sont stockés :\n\nd’une part dans Ppci/Views/templates/ppci, qui comprend toutes les pages gérées par Ppci, ainsi que la page par défaut (main.html)\nd’autre part dans App/Views/templates, pour les pages spécifiques de l’application.\n\nAu moment du déclenchement de l’affichage, la classe va :\n\nencoder les variables en HTML\ngénérer le jeton CSRF\nafficher les messages stockés dans la classe Message\ngénérer le menu de l’application\nrajouter divers contenus génériques, comme le titre de l’application.\n\n\n\nEnvoi d’un fichier binaire au navigateur\n$view = service (\"BinaryView\");\nLa classe permet d’envoyer le fichier soit “en ligne”, soit en “attachement”. Elle peut soit envoyer un fichier à partir de son adresse dans le serveur, soit un fichier déjà ouvert (handle). Elle va également rechercher le type MIME si celui-ci n’est pas fourni.\nPour fonctionner, il est nécessaire d’indiquer des paramètres particuliers :\n$param = array(\n        \"filename\" =&gt; \"\", /* nom du fichier tel qu'il apparaitra dans le navigateur */\n        \"disposition\" =&gt; \"attachment\", /* attachment : le fichier est telecharge, inline : le fichier est affiche */\n        \"tmp_name\" =&gt; \"\", /* emplacement du fichier dans le serveur */\n        \"content_type\" =&gt; \"\", /* type mime */\n        \"is_reference\" =&gt; false, /* if true, tmp_name contains the handle of the opened file */\n        \"handle\" =&gt; 0;\nsetParam(?array $param);\n\n\nEnvoi d’un fichier\n$view = service (\"FileView\");\nLe fonctionnement est assez semblable à BinaryView, à ceci près que cela ne travaille qu’à partir d’un fichier existant. le type MIME peut également être recherché automatiquement s’il n’est pas indiqué.\n$param = array(\n        \"filename\" =&gt; \"export.txt\", /* nom du fichier tel qu'il apparaitra dans le navigateur */\n        \"disposition\" =&gt; \"attachment\", /* attachment : le fichier est telecharge, inline : le fichier est affiche */\n        \"content_type\" =&gt; \"\", /* type mime */\n        \"tmp_name\" =&gt; \"\", /* Name of the file to send */\n    );\n\n\nRequête Ajax\n$view = service (\"AjaxView\");\nVue utilisée pour répondre à une requête Ajax. Le contenu, qui est fourni par défaut sous forme de tableau (contenu Json possible en positionnant la variable is_json à true, est encodé en html puis transformé en chaîne JSON avant d’être envoyé au navigateur.\n\n\nEnvoi d’un fichier CSV\n$view = service (\"CsvView\");\nCette vue va permettre de générer un fichier CSV à partir d’un tableau ($data[][]). La génération et l’envoi du fichier est réalisé avec la fonction :\nfunction send($filename = \"\", $delimiter = \"\")\nLe nom du fichier peut être généré automatiquement. Le délimiteur peut être le point-virgule, la virgule ou la tabulation (indiquer ). La première ligne d’entête est générée à partir des clés du premier enregistrement du tableau.\n\n\nEnvoi d’un fichier JSON\n$view = service (\"JsonFileView\");\nLa vue génère un fichier dans le navigateur, avec un fonctionnement proche de la vue Ajax. Si les données sont fournies à la classe sous forme de tableau, celles-ci sont encodées en html avant transformation en Json.\n\n\nEnvoi d’un fichier PDF\n$view = service (\"PdfView\");\nTransfert un fichier PDF, soit directement pour être affiché, soit en fichier attaché. Même fonctionnement que la vue FileView.\n\n\nEnvoi un contenu arbitraire au navigateur\n$view = service (\"DisplayView\");\nC’est une vue qui transmet au navigateur un contenu quelconque, sans encodage ni type MIME."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "PPCI - PrototypePHP for CodeIgniter",
    "section": "",
    "text": "PrototypePHP for CodeIgniter (PPCI) est un composant créé par Éric Quinton (INRAE - EABX à Cestas - Gironde, France) permettant de disposer d’un squelette d’application complet, intégrant :\n\nun menu généré en tenant compte des droits de l’utilisateur\nune gestion avancée des droits, avec de multiples mécanismes de connexion possibles\nune traçabilité des opérations effectuées (logs)\ndes utilitaires, comme la possibilité d’exécuter des requêtes SQL, une sauvegarde de la base de données, la visualisation de sa structure, etc.\n\nBasé sur le concept MVC, il utilise le moteur de rendu HTML SMARTY, avec une gestion intégrée de Bootstrap 3, des tableaux générés avec Datatables, etc.\nLe composant est distribué sous licence BSD.\nCopyright © Éric Quinton, pour INRAE - 2024 - tous droits réservés"
  },
  {
    "objectID": "workpackage2.html",
    "href": "workpackage2.html",
    "title": "Description of the workpackage 2",
    "section": "",
    "text": "Description of the workpackage 2"
  },
  {
    "objectID": "workpackage1.html",
    "href": "workpackage1.html",
    "title": "Description of the workpackage 1",
    "section": "",
    "text": "Description of the workpackage 1"
  },
  {
    "objectID": "posts/2024-03-11/newsletter_01.html",
    "href": "posts/2024-03-11/newsletter_01.html",
    "title": "Newsletter #1",
    "section": "",
    "text": "Example"
  },
  {
    "objectID": "partners.html#list-of-financial-partners",
    "href": "partners.html#list-of-financial-partners",
    "title": "Partners",
    "section": "List of Financial partners",
    "text": "List of Financial partners"
  },
  {
    "objectID": "principes.html",
    "href": "principes.html",
    "title": "Enchaînement lors de l’appel d’une page",
    "section": "",
    "text": "Vérification du jeton CSRF, présent dans tous les formulaires Smarty\n\n\n\nVérifie l’encodage des caractères transmis depuis le navigateur\n\n\n\nUtilisé pour transformer les adresses de type : index.php?module=nomModule (liens dans les pages web) en route nomModule. Les variables $_GET et $_REQUEST sont stockées en flashdata.\n\n\n\nLance PpciInit:init() - Avant le démarrage de la session : exécute le script App/Libraries/BeforeSession::index(), pour charger au besoin des classes avant le démarrage de la session - démarre la session - helper(‘ppci’) : charge les fonctions génériques de PPCI - initialise les messages qui ont été transmis avant une redirection - lit le fichier de paramétrage param.ini (utilisé pour les instances multi-adresses), et met à jour les paramètres dans App, Database et IdentificationConfig - met à jour la locale et le fichier des traductions - initialise la connexion à la base de données - purge les logs (table gacl.log). Les logs de plus d’un an sont supprimées\n\n\n\n\nrecherche les droits nécessaires dans :\n\nApp/Config/Rights\nPpci/Config/Rights\n\ns’il existe des droits demandés, vérifie si le login existe ou non. S’il n’existe pas, déclenche la procédure de connexion (Ppci/Libraries/Login-&gt;getLogin())\nvérifie que l’utilisateur dispose des droits nécessaires\n\n\n\n\n\nrecherche si le module appelé nécessite le droit admin dans Ppci/Config/Rights\nen cas de module d’administration :\n\nvérifie à quand remonte la dernière identification TOTP ou le dernier appel à un module d’administration\nsi la durée est &gt; 10’ :\n\nsi le compte n’a pas activé le TOTP, affichage de l’écran de création du code TOTP\ndéclenche la saisie du code TOTP\n\n\n\nL’utilisation du TOTP est désactivable (non conseillé en production) avec le paramètre IdentificationConfig\\disableTotpAdmin=1\n\n\n\n\nLes contrôleurs doivent hériter de Ppci/Controllers/PpciController, qui va récupérer depuis FlashData les variables $_GET, $_REQUEST, $_POST et $_SESSION[“lastGet”].\n\n\n\nLes contrôleurs font appel aux librairies, qui peuvent hériter de Ppci. Cette classe propose :\n\ndes paramètres pré-positionnés :\n\nprotected PpciModel $dataClass; : classe permettant de manipuler les informations stockées dans une table\n$this-&gt;message = service('MessagePpci'); : classe permettant d’afficher les messages à l’écran ou de les enregistrer dans les logs du serveur\n$this-&gt;appConfig = config(\"App\"); : paramètres généraux de l’application\n$this-&gt;log = service(\"Log\"); : enregistrement des actions dans la table gacl.log\n\ndes fonctions génériques pour manipuler les données :\n\ndataRead($id, $smartyPage, $idParent = 0) : lit les informations d’un enregistrement dans la classe $dataClass, et génère la vue Smarty\ndataWrite(array $data, bool $isPartOfTransaction = false) : écrit les informations dans la base de données\ndataDelete($id, bool $isPartOfTransaction = false) : supprime un enregistrement\n\n\n\n\n\nL’envoi d’informations au navigateur fait appel à des vues, chacune étant dédiée à un type d’informations (pages web, fichiers pdf, requêtes Ajax, fichiers binaires, etc.). Elles sont disponibles sous forme de services (décrits dans ppci/Config/Services.php), et sont physiquement stockées dans Ppci/Libraries/Views.\nLe détail des vues peut être consulté ici."
  },
  {
    "objectID": "principes.html#filtres",
    "href": "principes.html#filtres",
    "title": "Enchaînement lors de l’appel d’une page",
    "section": "",
    "text": "Vérification du jeton CSRF, présent dans tous les formulaires Smarty\n\n\n\nVérifie l’encodage des caractères transmis depuis le navigateur\n\n\n\nUtilisé pour transformer les adresses de type : index.php?module=nomModule (liens dans les pages web) en route nomModule. Les variables $_GET et $_REQUEST sont stockées en flashdata.\n\n\n\nLance PpciInit:init() - Avant le démarrage de la session : exécute le script App/Libraries/BeforeSession::index(), pour charger au besoin des classes avant le démarrage de la session - démarre la session - helper(‘ppci’) : charge les fonctions génériques de PPCI - initialise les messages qui ont été transmis avant une redirection - lit le fichier de paramétrage param.ini (utilisé pour les instances multi-adresses), et met à jour les paramètres dans App, Database et IdentificationConfig - met à jour la locale et le fichier des traductions - initialise la connexion à la base de données - purge les logs (table gacl.log). Les logs de plus d’un an sont supprimées\n\n\n\n\nrecherche les droits nécessaires dans :\n\nApp/Config/Rights\nPpci/Config/Rights\n\ns’il existe des droits demandés, vérifie si le login existe ou non. S’il n’existe pas, déclenche la procédure de connexion (Ppci/Libraries/Login-&gt;getLogin())\nvérifie que l’utilisateur dispose des droits nécessaires\n\n\n\n\n\nrecherche si le module appelé nécessite le droit admin dans Ppci/Config/Rights\nen cas de module d’administration :\n\nvérifie à quand remonte la dernière identification TOTP ou le dernier appel à un module d’administration\nsi la durée est &gt; 10’ :\n\nsi le compte n’a pas activé le TOTP, affichage de l’écran de création du code TOTP\ndéclenche la saisie du code TOTP\n\n\n\nL’utilisation du TOTP est désactivable (non conseillé en production) avec le paramètre IdentificationConfig\\disableTotpAdmin=1"
  },
  {
    "objectID": "principes.html#appel-du-contrôleur",
    "href": "principes.html#appel-du-contrôleur",
    "title": "Enchaînement lors de l’appel d’une page",
    "section": "",
    "text": "Les contrôleurs doivent hériter de Ppci/Controllers/PpciController, qui va récupérer depuis FlashData les variables $_GET, $_REQUEST, $_POST et $_SESSION[“lastGet”]."
  },
  {
    "objectID": "principes.html#appel-des-librairies",
    "href": "principes.html#appel-des-librairies",
    "title": "Enchaînement lors de l’appel d’une page",
    "section": "",
    "text": "Les contrôleurs font appel aux librairies, qui peuvent hériter de Ppci. Cette classe propose :\n\ndes paramètres pré-positionnés :\n\nprotected PpciModel $dataClass; : classe permettant de manipuler les informations stockées dans une table\n$this-&gt;message = service('MessagePpci'); : classe permettant d’afficher les messages à l’écran ou de les enregistrer dans les logs du serveur\n$this-&gt;appConfig = config(\"App\"); : paramètres généraux de l’application\n$this-&gt;log = service(\"Log\"); : enregistrement des actions dans la table gacl.log\n\ndes fonctions génériques pour manipuler les données :\n\ndataRead($id, $smartyPage, $idParent = 0) : lit les informations d’un enregistrement dans la classe $dataClass, et génère la vue Smarty\ndataWrite(array $data, bool $isPartOfTransaction = false) : écrit les informations dans la base de données\ndataDelete($id, bool $isPartOfTransaction = false) : supprime un enregistrement"
  },
  {
    "objectID": "principes.html#les-différentes-vues",
    "href": "principes.html#les-différentes-vues",
    "title": "Enchaînement lors de l’appel d’une page",
    "section": "",
    "text": "L’envoi d’informations au navigateur fait appel à des vues, chacune étant dédiée à un type d’informations (pages web, fichiers pdf, requêtes Ajax, fichiers binaires, etc.). Elles sont disponibles sous forme de services (décrits dans ppci/Config/Services.php), et sont physiquement stockées dans Ppci/Libraries/Views.\nLe détail des vues peut être consulté ici."
  }
]