[
  {
    "objectID": "legal_notice.html",
    "href": "legal_notice.html",
    "title": "PPCI - PrototypePHP for CodeIgniter",
    "section": "",
    "text": "Nom du site : documentation PPCI\nURL complète du site : https://equinton.github.io/ppcidocs/"
  },
  {
    "objectID": "legal_notice.html#identification-du-site",
    "href": "legal_notice.html#identification-du-site",
    "title": "PPCI - PrototypePHP for CodeIgniter",
    "section": "",
    "text": "Nom du site : documentation PPCI\nURL complète du site : https://equinton.github.io/ppcidocs/"
  },
  {
    "objectID": "legal_notice.html#éditeurs-du-site",
    "href": "legal_notice.html#éditeurs-du-site",
    "title": "PPCI - PrototypePHP for CodeIgniter",
    "section": "Éditeur(s) du site",
    "text": "Éditeur(s) du site\nINRAE - Institut national de recherche pour l’agriculture, l’alimentation et l’environnement\nINRAE est un établissement public à caractère scientifique et technologique. Il a son siège au 147, rue de l’université – 75338 Paris cedex 07. Ses statuts sont publiés dans le code rural et de la pêche maritime (articles R831-1 et suivants).\nIl est représenté par son Président Directeur général, M. Philippe MAUGUIN.\nContact mail: web@inrae.fr - contact téléphonique: 01 42 75 90 00"
  },
  {
    "objectID": "legal_notice.html#numéros-didentification",
    "href": "legal_notice.html#numéros-didentification",
    "title": "PPCI - PrototypePHP for CodeIgniter",
    "section": "Numéros d’identification",
    "text": "Numéros d’identification\nINRAE SIREN: 180070039\nCode APE: 7219Z\nNuméro de TVA intracommunautaire: FR 57 1800700039"
  },
  {
    "objectID": "legal_notice.html#publication-du-site",
    "href": "legal_notice.html#publication-du-site",
    "title": "PPCI - PrototypePHP for CodeIgniter",
    "section": "Publication du site",
    "text": "Publication du site\nNom du directeur de publication : M. Philippe MAUGUIN\nNom du responsable de rédaction : Éric Quinton\nWebmaster du site : Éric Quinton"
  },
  {
    "objectID": "legal_notice.html#hébergeur-du-site",
    "href": "legal_notice.html#hébergeur-du-site",
    "title": "PPCI - PrototypePHP for CodeIgniter",
    "section": "Hébergeur du site",
    "text": "Hébergeur du site\nINRAE Établissement public à caractère scientifique et technologique 147, rue de l’université – 75338 Paris cedex 07 01 42 75 90 00\nCopyright © 2024 - All rights reserved. Author: Éric Quinton for EABX-INRAE. Documentation distributed under license  CC-BY"
  },
  {
    "objectID": "migration.html",
    "href": "migration.html",
    "title": "Migration depuis PrototypePhp",
    "section": "",
    "text": "Créez un dossier différent de celui qui contient le code initial de l’application à migrer, par exemple app2, puis, depuis le répertoire de niveau inférieur :\ncomposer create-project codeigniter4/appstarter app2\ncd app2\ncomposer require app2/ppci\nvendor/app2/ppci/install/install.sh\nÉditez ensuite le fichier .env, et mettez à jour les paramètres nécessaires (CI_ENVIRONMENT, app.baseURL et les paramètres de connexion à la base de données).\n\n\n\nVoici un exemple de configuration :\n&lt;VirtualHost *:80&gt;\n    ServerName app2.local\n    ServerPath /app2.local\n    RewriteEngine On\n    RewriteRule ^ https://app2.local%{REQUEST_URI} [R]\n&lt;/VirtualHost&gt;\n&lt;VirtualHost *:443&gt;\n    ServerName app2.local\n    ServerPath /app2.local\n    SSLEngine on\n    SSLCertificateFile  /etc/ssl/certs/server.crt\n    SSLCertificateKeyFile /etc/ssl/private/server.key\n    SSLCACertificateFile /etc/ssl/certs/cacert.crt\n    DocumentRoot /var/www/app2/public \n&lt;/VirtualHost&gt;\n&lt;Directory /var/www/app2/public&gt;\n    Options FollowSymLinks MultiViews\n    Require all granted\n    AllowOverride all\n    RewriteEngine On\n    RewriteBase /\n    RewriteCond \"/%{REQUEST_FILENAME}\" !-f\n    RewriteCond \"/%{REQUEST_FILENAME}\" !-d\n    RewriteRule \"(.*)\" \"/index.php?$1\" [PT,QSA]\n&lt;/Directory&gt;\n\n\n\nÉditez le fichier vendor/equinton/ppci/migration/updatedb.sql, et vérifiez la première ligne (set search_path), en remplaçant app par le nom du schéma contenant les données.\nExécutez ensuite le fichier sql.\n\n\n\nÉditez le fichier app/Config/menu.xml, et rajoutez les entrées nécessaires.\n\n\n\nRecopiez les modèles Smarty depuis display/templates dans app/Views/templates en conservant l’organisation en sous-dossiers, à l’exception des fichiers à la racine et du sous-dossier framework.\n\n\nDans ce dossier, remplacez tous les libellés (filtre sur *tpl) : - &lt;/form&gt; par {$csrf}&lt;/form&gt; pour ajouter le jeton CSRF dans les formulaires - droits par rights - .gestion par .manage - &lt;script&gt; par &lt;script {$csp_script_nonce}&gt;\nSupprimez\n\nindex.php?module=\n\n\n\n\nReprenez tous les liens (recherchez les balises &lt;a href&gt;) et remplacez le premier & par ?\nModifiez toutes les actions des formulaires, pour qu’ils aient cette forme :\n&lt;form class=\"form-horizontal\" id=\"formName\" method=\"post\" action=\"moduleWrite\"&gt;\n&lt;input type=\"hidden\" name=\"moduleBase\" value=\"module\"&gt;\nLe champ action peut être supprimé. Par contre, le champ moduleBase doit être conservé : il est utilisé pour créer l’action moduleDelete par l’intermédiaire du script javascript dans main_js.tpl. Toutefois, si les modifications ne sont pas réalisées, le script créera automatiquement la bonne action à partir des champs moduleBase et action lors de l’envoi du formulaire.\n\n\n\n\n\nAjouter un filtre pour réaliser les opérations décrites dans modules/common.php ;\nrenseigner le cas échéant la classe App\\Libraries\\Postlogin, pour réaliser les opérations spécifiques après connexion.\n\n\n\n\nRecopier les fichiers depuis modules/classes vers app/Models.\n\n\nElles peuvent être effectuées par rechercher/remplacer.\n\nremplacer :\n\n&lt;?php par &lt;?php namespace App\\Models;use Ppci\\Models\\PpciModel;, avec sauts de ligne ;\nextends ObjetBDD par extends PpciModel ;\n(public function __construct().*) par public function __construct(), en cochant expression régulière ;\n$this-&gt;colonnes par $this-&gt;fields ;\nfunction ecrire par function write\nfunction lire par function read\nparent::ecrire par parent::write\n(parent::__construct().*) par parent::__construct(), en cochant expression régulière ;\n$this-&gt;id_auto = 0 par $this-&gt;useAutoIncrement = false\nauto_date = 0 par autoFormatDate = false\n\nsupprimer :\n\n$this-&gt;id_auto = 1;\n$param[\"fullDescription\"] = 1;\n\n\n\n\n\n\nrenommer le nom du fichier, par exemple espece.class.php en Espece.php ;\ndans les requêtes SQL, modifier les variables en rajoutant : à la fin : :id doit devenir :id: ;\npour les tables portant des données géographiques (champs avec type=4), modifier les requêtes ou créer les fonctions lire() pour ajouter st_astext() pour les champs concernés ;\nles transformations de dates pour les champs non présents dans la table doivent être réécrites selon ce schéma :\n\n$this-&gt;dateFields[] = \"peche_date\";\n$this-&gt;datetimeFields[] = \"peche_datetime\";\n\n\n\n\nRecopier l’ensemble des modules dans app/Libraries. Il faut les transformer en classes.\n\n\nRemplacer :\n\n&lt;?php par :\n\n&lt;?php \nnamespace App\\Libraries;\n\nuse Ppci\\Libraries\\PpciException;\nuse Ppci\\Libraries\\PpciLibrary;\nuse Ppci\\Models\\PpciModel;\n\nclass Xx extends PpciLibrary { \n    /**\n     * @var xx\n     */\n    protected PpciModel $dataclass;\n\n    function __construct()\n    {\n        parent::__construct();\n        $this-&gt;dataClass = new \\App\\Models\\XXX();\n        $keyName = \"xxx_id\";\n        if (isset($_REQUEST[$keyName])) {\n            $this-&gt;id = $_REQUEST[$keyName];\n        }\n    }\n\ndataRead($dataClass, par $this-&gt;dataRead(\ndataWrite($dataClass, par $this-&gt;dataWrite(\ndataDelete($dataClass, par $this-&gt;dataDelete(\ncase \"list\": par function list(){$vue=service('Smarty'); (saut de ligne)\ncase \"display\": par function display(){$vue=service('Smarty'); (saut de ligne)\ncase \"change\": par function change(){$vue=service('Smarty'); (saut de ligne)\ncase \"write\": par function write(){\ncase \"delete\": par function delete(){\ncase \" par function\n\": par () {\nbreak; par } : fermeture des fonctions\n$dataclass par $this-&gt;dataClass\n$id par $this-&gt;id\n$vue par $this-&gt;vue\n$this-&gt;dataDelete($this-&gt;id); par\n\n        try {\n            $this-&gt;dataDelete($this-&gt;id);\n            return $this-&gt;list();\n        } catch (PpciException $e) {\n            return $this-&gt;change();\n        }\n\n$message-&gt; par $this-&gt;message-&gt;\n\net suppression de :\n\nswitch ($t_module[\"param\"]) {\n$bdd, $ObjetBDDParam\n\n\n\n\n\nrenommer le fichier en le commençant par une majuscule\nModifier la fonction __construct() pour charger la bonne classe et le bon identifiant\ndéfinir les vues autres que Smarty dans les fonctions\ndéfinir le retour attendu de chaque fonction :\n\nsoit ajouter la commande return $this-&gt;vue-&gt;send(); pour déclencher l’affichage\nsoit renvoyer vers une des fonctions de la classe : return $this-&gt;display();\nsoit renvoyer vers la page d’accueil : defaultPage();\n\n\n\n\n\n\nExécutez la commande suivante :\nphp vendor/equinton/ppci/migration/actionsParse.php ../app/param/actions.xml\nLe script va lire l’ancien fichier actions.xml, et va préparer deux contenus :\n\nle premier est destiné à être inséré dans la classe app\\Config\\Rights, et contient la liste des droits nécessaires pour exécuter un module\nle second contient un prototype des routes pour exécuter les modules. Le contenu doit être inséré dans app/Config/Routes.php.\n\n\n\n\nUtilisez une fonction de recherche automatique pour remplacer “gestion” par “manage”.\n\n\n\nLancez le script :\nphp vendor/equinton/ppci/migration/generateController.php app/Config/Routes.php app/Controllers/\nLe programme va lire les routes définies, puis créer les contrôleurs correspondants, en regroupant les routes par module. Les contrôleurs intègrent lles appels aux fonctions de la librairie correspondante (même nom).\n\n\n\nÉditez le fichier app/Config/menu.xml, pour ajouter les entrées nécessaires à l’application et supprimer celles qui n’ont pas lieu d’être présentes.\n\n\n\nÉditez les fichiers suivants :\n\napp/Config/news.txt pour les nouveautés en français\napp/Config/newsen.txt pour les nouveautés en anglais\n\nÉditez également les templates suivants :\n\napp/Views/templates/about_fr.tpl\napp/Views/templates/about_en.tpl"
  },
  {
    "objectID": "migration.html#installer-codeigniter-et-ppci",
    "href": "migration.html#installer-codeigniter-et-ppci",
    "title": "Migration depuis PrototypePhp",
    "section": "",
    "text": "Créez un dossier différent de celui qui contient le code initial de l’application à migrer, par exemple app2, puis, depuis le répertoire de niveau inférieur :\ncomposer create-project codeigniter4/appstarter app2\ncd app2\ncomposer require app2/ppci\nvendor/app2/ppci/install/install.sh\nÉditez ensuite le fichier .env, et mettez à jour les paramètres nécessaires (CI_ENVIRONMENT, app.baseURL et les paramètres de connexion à la base de données)."
  },
  {
    "objectID": "migration.html#créer-un-nouveau-vhost-dans-apache",
    "href": "migration.html#créer-un-nouveau-vhost-dans-apache",
    "title": "Migration depuis PrototypePhp",
    "section": "",
    "text": "Voici un exemple de configuration :\n&lt;VirtualHost *:80&gt;\n    ServerName app2.local\n    ServerPath /app2.local\n    RewriteEngine On\n    RewriteRule ^ https://app2.local%{REQUEST_URI} [R]\n&lt;/VirtualHost&gt;\n&lt;VirtualHost *:443&gt;\n    ServerName app2.local\n    ServerPath /app2.local\n    SSLEngine on\n    SSLCertificateFile  /etc/ssl/certs/server.crt\n    SSLCertificateKeyFile /etc/ssl/private/server.key\n    SSLCACertificateFile /etc/ssl/certs/cacert.crt\n    DocumentRoot /var/www/app2/public \n&lt;/VirtualHost&gt;\n&lt;Directory /var/www/app2/public&gt;\n    Options FollowSymLinks MultiViews\n    Require all granted\n    AllowOverride all\n    RewriteEngine On\n    RewriteBase /\n    RewriteCond \"/%{REQUEST_FILENAME}\" !-f\n    RewriteCond \"/%{REQUEST_FILENAME}\" !-d\n    RewriteRule \"(.*)\" \"/index.php?$1\" [PT,QSA]\n&lt;/Directory&gt;"
  },
  {
    "objectID": "partners.html#list-of-financial-partners",
    "href": "partners.html#list-of-financial-partners",
    "title": "Partners",
    "section": "List of Financial partners",
    "text": "List of Financial partners"
  },
  {
    "objectID": "identification.html",
    "href": "identification.html",
    "title": "Gestion de l’identification",
    "section": "",
    "text": "Gestion de l’identification"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "PPCI - PrototypePHP for CodeIgniter",
    "section": "",
    "text": "PrototypePHP for CodeIgniter (PPCI) est un portage du framework https://github.com/equinton/prototypephp développé à partir des années 2000 pour écrire divers applications web, dont Collec-Science.\nPour faciliter la maintenance des applications web, le portage vers CodeIgniter de PrototypePHP a été entrepris en 2024. Il se présente sous la forme d’un composant additionnel. Il utilise la plupart des fonctionnalités de CodeIgniter (routes, filtres, services, accès aux bases de données, gestion des paramètres, etc.), à l’exception :\n\nde l’affichage des pages web, qui reste dévolu au moteur de templates Smarty\nde la gestion de l’identification et des droits, PPCI étant à cet égard bien plus riche en terme de fonctionnalités, comme le support de multiples mécanismes d’identification (en base de données, LDAP, CAS, OIDC, TOTP, etc.) ou la gestion des droits.\n\nLe composant est distribué sous licence MIT."
  },
  {
    "objectID": "parameters.html",
    "href": "parameters.html",
    "title": "Paramètres de l’application",
    "section": "",
    "text": "Paramètres de l’application"
  },
  {
    "objectID": "command-line.html",
    "href": "command-line.html",
    "title": "Exécution en ligne de commande",
    "section": "",
    "text": "Dans CodeIgniter, avec le module PPCI, le fichier est généré automatiquement avec ce code :\nif (is_file($file = $_SERVER[\"envPath\"] . DIRECTORY_SEPARATOR . \".env\") && is_readable($file)) {\n    (new CodeIgniter\\Config\\DotEnv($_SERVER[\"envPath\"],\".env\"))-&gt;load();\nPour transférer la valeur de envPath dans la variable $_SERVER, dans le script permettant d’exécuter le code :\n#!/bin/bash\nexport envPath=\"/home/equinton/web/metabo2\"\nphp test.php\n\n/home/equinton/web/metabo2\nAvec test.php :\n&lt;?php\n\necho $_SERVER[\"envPath\"].PHP_EOL;"
  },
  {
    "objectID": "command-line.html#transférer-le-nom-du-fichier-.env-à-utiliser",
    "href": "command-line.html#transférer-le-nom-du-fichier-.env-à-utiliser",
    "title": "Exécution en ligne de commande",
    "section": "",
    "text": "Dans CodeIgniter, avec le module PPCI, le fichier est généré automatiquement avec ce code :\nif (is_file($file = $_SERVER[\"envPath\"] . DIRECTORY_SEPARATOR . \".env\") && is_readable($file)) {\n    (new CodeIgniter\\Config\\DotEnv($_SERVER[\"envPath\"],\".env\"))-&gt;load();\nPour transférer la valeur de envPath dans la variable $_SERVER, dans le script permettant d’exécuter le code :\n#!/bin/bash\nexport envPath=\"/home/equinton/web/metabo2\"\nphp test.php\n\n/home/equinton/web/metabo2\nAvec test.php :\n&lt;?php\n\necho $_SERVER[\"envPath\"].PHP_EOL;"
  },
  {
    "objectID": "multi-instance.html",
    "href": "multi-instance.html",
    "title": "Gestion du multi-instances",
    "section": "",
    "text": "Créez un dossier dédié à l’instance dans l’arborescence du serveur, par exemple /var/www/app/instancename, puis créez les fichiers nécessaires pour assurer la séparation des instances :\n# Dossier contenant le code de l'application\nAPP=/var/www/app\n# Dossier comprenant les paramètres spécifiques de l'instance\nFOLDER=\"/var/www/instances/instancename\"\nmkdir -P $FOLDER\nchmod g+r $FOLDER\ncd $FOLDER\nmkdir temp\n# Nouvelles cles cryptographiques\nopenssl genpkey -algorithm rsa -out id_app -pkeyopt rsa_keygen_bits:2048\nopenssl rsa -in id_app -pubout -out id_app.pub\n# Recopie du fichier de parametrage\ncp $APP/.env .\n# Mise à niveau des droits\nchmod -R g+r $FOLDER\nchmod g+w temp\nchown www-data id_app\nRecopiez le fichier .env de l’application dans ce dossier.\n\n\n\nRajoutez, dans la description du site virtuel (fichier moninstance.conf, dans /etc/apache2/sites-available) :\n&lt;VirtualHost *:443&gt;\n    (...)\n    DocumentRoot /var/www/app\n    setenv envPath /var/www/instances/instancename\n    (...)  \n\n\n\nÉditez le fichier /var/www/instances/instancename/.env :\napp.baseURL = 'https://myinstance.mysociety.com'\napp.BASE_DIR = \"/var/www/instances/instancename\"\napp.privateKey = ${BASE_DIR}/id_app\napp.pubKey = ${BASE_DIR}/id_app.pub\napp.APP_temp = ${BASE_DIR}/temp\ndatabase.default.hostname = localhost\ndatabase.default.database = dbname_instance\ndatabase.default.username = login_instance\ndatabase.default.password = password_instance\nVérifiez également le mode d’identification par défaut, et adaptez-le le cas échéant.\n\n\n\nSi vous utilisez des scripts qui sont exécutés en ligne de commande, par exemple programmés à horaires réguliers (crontab), vous devrez modifier :\n\nd’une part, le script de lancement :\n\n#!/bin/bash\nexport envPath=/var/www/instances/instancename\nphp commandline.php\nLa variable envPath est disponible dans $_SERVER.\nLa fonction loadDotEnv(Paths $paths) de la classe vendor/codeigniter4/framework/system/Boot.php doit être réécrite ainsi :\n    /**\n     * Load environment settings from .env files into $_SERVER and $_ENV\n     */\n    protected static function loadDotEnv(Paths $paths): void\n    {\n        require_once $paths-&gt;systemDirectory . '/Config/DotEnv.php';\n        if (is_file($file = $_SERVER[\"envPath\"] . DIRECTORY_SEPARATOR . \".env\") && is_readable($file)) {\n        (new CodeIgniter\\Config\\DotEnv($_SERVER[\"envPath\"],\".env\"))-&gt;load();\n        } else {\n            (new CodeIgniter\\Config\\DotEnv($paths-&gt;appDirectory . '/../'))-&gt;load();\n        }\n    }"
  },
  {
    "objectID": "multi-instance.html#créer-le-dossier-dédié-à-linstance",
    "href": "multi-instance.html#créer-le-dossier-dédié-à-linstance",
    "title": "Gestion du multi-instances",
    "section": "",
    "text": "Créez un dossier dédié à l’instance dans l’arborescence du serveur, par exemple /var/www/app/instancename, puis créez les fichiers nécessaires pour assurer la séparation des instances :\n# Dossier contenant le code de l'application\nAPP=/var/www/app\n# Dossier comprenant les paramètres spécifiques de l'instance\nFOLDER=\"/var/www/instances/instancename\"\nmkdir -P $FOLDER\nchmod g+r $FOLDER\ncd $FOLDER\nmkdir temp\n# Nouvelles cles cryptographiques\nopenssl genpkey -algorithm rsa -out id_app -pkeyopt rsa_keygen_bits:2048\nopenssl rsa -in id_app -pubout -out id_app.pub\n# Recopie du fichier de parametrage\ncp $APP/.env .\n# Mise à niveau des droits\nchmod -R g+r $FOLDER\nchmod g+w temp\nchown www-data id_app\nRecopiez le fichier .env de l’application dans ce dossier."
  },
  {
    "objectID": "multi-instance.html#mettre-à-niveau-du-site-virtuel-apache",
    "href": "multi-instance.html#mettre-à-niveau-du-site-virtuel-apache",
    "title": "Gestion du multi-instances",
    "section": "",
    "text": "Rajoutez, dans la description du site virtuel (fichier moninstance.conf, dans /etc/apache2/sites-available) :\n&lt;VirtualHost *:443&gt;\n    (...)\n    DocumentRoot /var/www/app\n    setenv envPath /var/www/instances/instancename\n    (...)"
  },
  {
    "objectID": "multi-instance.html#modifier-les-paramètres",
    "href": "multi-instance.html#modifier-les-paramètres",
    "title": "Gestion du multi-instances",
    "section": "",
    "text": "Éditez le fichier /var/www/instances/instancename/.env :\napp.baseURL = 'https://myinstance.mysociety.com'\napp.BASE_DIR = \"/var/www/instances/instancename\"\napp.privateKey = ${BASE_DIR}/id_app\napp.pubKey = ${BASE_DIR}/id_app.pub\napp.APP_temp = ${BASE_DIR}/temp\ndatabase.default.hostname = localhost\ndatabase.default.database = dbname_instance\ndatabase.default.username = login_instance\ndatabase.default.password = password_instance\nVérifiez également le mode d’identification par défaut, et adaptez-le le cas échéant."
  },
  {
    "objectID": "multi-instance.html#adapter-les-scripts-lancés-en-ligne-de-commande",
    "href": "multi-instance.html#adapter-les-scripts-lancés-en-ligne-de-commande",
    "title": "Gestion du multi-instances",
    "section": "",
    "text": "Si vous utilisez des scripts qui sont exécutés en ligne de commande, par exemple programmés à horaires réguliers (crontab), vous devrez modifier :\n\nd’une part, le script de lancement :\n\n#!/bin/bash\nexport envPath=/var/www/instances/instancename\nphp commandline.php\nLa variable envPath est disponible dans $_SERVER.\nLa fonction loadDotEnv(Paths $paths) de la classe vendor/codeigniter4/framework/system/Boot.php doit être réécrite ainsi :\n    /**\n     * Load environment settings from .env files into $_SERVER and $_ENV\n     */\n    protected static function loadDotEnv(Paths $paths): void\n    {\n        require_once $paths-&gt;systemDirectory . '/Config/DotEnv.php';\n        if (is_file($file = $_SERVER[\"envPath\"] . DIRECTORY_SEPARATOR . \".env\") && is_readable($file)) {\n        (new CodeIgniter\\Config\\DotEnv($_SERVER[\"envPath\"],\".env\"))-&gt;load();\n        } else {\n            (new CodeIgniter\\Config\\DotEnv($paths-&gt;appDirectory . '/../'))-&gt;load();\n        }\n    }"
  },
  {
    "objectID": "rights.html",
    "href": "rights.html",
    "title": "Droits d’accès aux modules",
    "section": "",
    "text": "Droits d’accès aux modules"
  },
  {
    "objectID": "model.html",
    "href": "model.html",
    "title": "Gestion des accès aux données stockées en base de données",
    "section": "",
    "text": "Gestion des accès aux données stockées en base de données"
  },
  {
    "objectID": "functions.html",
    "href": "functions.html",
    "title": "Fonctions et services",
    "section": "",
    "text": "Les services permettent de conserver la même instance d’une classe tout au long de l’exécution du script. Ils sont décrits dans Ppci\\Config\\Services.\nIls s’appellent de la façon suivante :\n$monService = service ('name');\nLa première fois que le code est appelé, la classe est instanciée. Ensuite, l’instance de classe est fournie, ce qui permet de conserver les mêmes paramètres.\nTrois types de services sont configurés : des services génériques, les services fournissant les paramètres de configuration, et les vues.\n\n\n\n\nCode utilisé systématiquement à l’appel d’une page.\n\n\n\nClasse permettant de stocker des messages, puis de les restituer. Deux fonctions sont utilisables pour les enregistrer :\n\nfunction set(string $value, bool $is_error = false) : stocke un message. S’il s’agit d’une erreur, le message sera ensuite affiché en rouge\nfunction setSyslog($message, $is_error = false) : enregistre un message dans les logs du système. En mode développement, le message est affiché également à l’écran\n\n\n\n\nClasse permettant d’enregistrer une information dans la table gacl.log. Une entrée peut être créée avec la fonction $col-&gt;setLog($login, $module, $commentaire = null). La valeur login peut être récupérée à partir de $_SESSION[\"login\"]. $module représente le nom de la fonction ou de l’appel à enregistrer, et $commentaire un contenu particulier à noter.\n\n\n\nClasse permettant de paramétrer la langue à utiliser. Les libellés peuvent être modifiés avec la fonction setLocale($locale). Par défaut, seuls “fr” et “en” sont actuellement supportés.\n\n\n\n\n\n\nClasse contenant l’ensemble des paramètres stockés dans la table dbparam. Les paramètres sont accessibles avec l’attribut $dbparam-&gt;params[\"nom_parametre\"].\nLes paramètres sont également disponibles dans la variable $_SESSION[\"dbparams\"].\n\n\n\nContient les paramètres généraux de l’application (App\\Config\\App).\n\n\n\nContient les paramètres liés à l’identification (Ppci\\Config\\IdentificationConfig).\n\n\n\n\nLa description des vues peut être consultée ici.\n\n\n\n\nLes fonctions sont chargées automatiquement à partir de ppci/Helpers/ppci_helper.php.\n\ndefaultPage() : affiche la page d’accueil de l’application (sans redirection)\ngetLineFeed() : restitue le code de retour à la ligne en fonction du contexte : serveur web ou ligne de commande\nhtmlDecode($content) : fonction récursive permettant de décoder les caractères html (htmlspecialchars_decode())\nprintA($variable) : affiche le contenu d’une variable. Pour les tableaux, affiche le contenu du tableau. Utilisé pour le débogage\nsetlogRequest($request) : écrit dans la table gacl.log la requête demandée\ntest($var = \"\") : affiche le mot “test” et le numéro de l’occurrence où la fonction a été appelée. Si $var est renseigné, affiche son contenu"
  },
  {
    "objectID": "functions.html#services",
    "href": "functions.html#services",
    "title": "Fonctions et services",
    "section": "",
    "text": "Les services permettent de conserver la même instance d’une classe tout au long de l’exécution du script. Ils sont décrits dans Ppci\\Config\\Services.\nIls s’appellent de la façon suivante :\n$monService = service ('name');\nLa première fois que le code est appelé, la classe est instanciée. Ensuite, l’instance de classe est fournie, ce qui permet de conserver les mêmes paramètres.\nTrois types de services sont configurés : des services génériques, les services fournissant les paramètres de configuration, et les vues.\n\n\n\n\nCode utilisé systématiquement à l’appel d’une page.\n\n\n\nClasse permettant de stocker des messages, puis de les restituer. Deux fonctions sont utilisables pour les enregistrer :\n\nfunction set(string $value, bool $is_error = false) : stocke un message. S’il s’agit d’une erreur, le message sera ensuite affiché en rouge\nfunction setSyslog($message, $is_error = false) : enregistre un message dans les logs du système. En mode développement, le message est affiché également à l’écran\n\n\n\n\nClasse permettant d’enregistrer une information dans la table gacl.log. Une entrée peut être créée avec la fonction $col-&gt;setLog($login, $module, $commentaire = null). La valeur login peut être récupérée à partir de $_SESSION[\"login\"]. $module représente le nom de la fonction ou de l’appel à enregistrer, et $commentaire un contenu particulier à noter.\n\n\n\nClasse permettant de paramétrer la langue à utiliser. Les libellés peuvent être modifiés avec la fonction setLocale($locale). Par défaut, seuls “fr” et “en” sont actuellement supportés.\n\n\n\n\n\n\nClasse contenant l’ensemble des paramètres stockés dans la table dbparam. Les paramètres sont accessibles avec l’attribut $dbparam-&gt;params[\"nom_parametre\"].\nLes paramètres sont également disponibles dans la variable $_SESSION[\"dbparams\"].\n\n\n\nContient les paramètres généraux de l’application (App\\Config\\App).\n\n\n\nContient les paramètres liés à l’identification (Ppci\\Config\\IdentificationConfig).\n\n\n\n\nLa description des vues peut être consultée ici."
  },
  {
    "objectID": "functions.html#fonctions",
    "href": "functions.html#fonctions",
    "title": "Fonctions et services",
    "section": "",
    "text": "Les fonctions sont chargées automatiquement à partir de ppci/Helpers/ppci_helper.php.\n\ndefaultPage() : affiche la page d’accueil de l’application (sans redirection)\ngetLineFeed() : restitue le code de retour à la ligne en fonction du contexte : serveur web ou ligne de commande\nhtmlDecode($content) : fonction récursive permettant de décoder les caractères html (htmlspecialchars_decode())\nprintA($variable) : affiche le contenu d’une variable. Pour les tableaux, affiche le contenu du tableau. Utilisé pour le débogage\nsetlogRequest($request) : écrit dans la table gacl.log la requête demandée\ntest($var = \"\") : affiche le mot “test” et le numéro de l’occurrence où la fonction a été appelée. Si $var est renseigné, affiche son contenu"
  },
  {
    "objectID": "views.html",
    "href": "views.html",
    "title": "Les vues",
    "section": "",
    "text": "Les vues\nL’envoi d’informations au navigateur fait appel à des vues, chacune étant dédiée à un type d’informations (pages web, fichiers pdf, requêtes Ajax, fichiers binaires, etc.). Elles sont disponibles sous forme de services (décrits dans ppci/Config/Services.php), et sont physiquement stockées dans Ppci/Libraries/Views.\nToutes les vues héritent de la classe Ppci\\Libraries\\Views\\DefaultView, qui comprend les fonctions génériques suivantes :\n\nfunction set($value, $variable = \"\") : affecte un contenu (nommé ou non, si variable est renseigné) à la vue\nfunction get($variable = \"\") : récupère le contenu d’une variable ou le contenu affecté\nfunction encodehtml($data) : fonction récursive d’encodage en HTML des variables\nfunction send($param = \"\") : déclenche l’envoi des informations. Cette fonction est systématiquement réécrite dans chaque vue.\n\n\nAffichage des pages\n$view = service (\"Smarty\");\nLes pages web sont générées avec le moteur de templates Smarty. Les modèles sont stockés :\n\nd’une part dans Ppci/Views/templates/ppci, qui comprend toutes les pages gérées par Ppci, ainsi que la page par défaut (main.html)\nd’autre part dans App/Views/templates, pour les pages spécifiques de l’application.\n\nAu moment du déclenchement de l’affichage, la classe va :\n\nencoder les variables en HTML\ngénérer le jeton CSRF\nafficher les messages stockés dans la classe Message\ngénérer le menu de l’application\nrajouter divers contenus génériques, comme le titre de l’application.\n\n\n\nEnvoi d’un fichier binaire au navigateur\n$view = service (\"BinaryView\");\nLa classe permet d’envoyer le fichier soit “en ligne”, soit en “attachement”. Elle peut soit envoyer un fichier à partir de son adresse dans le serveur, soit un fichier déjà ouvert (handle). Elle va également rechercher le type MIME si celui-ci n’est pas fourni.\nPour fonctionner, il est nécessaire d’indiquer des paramètres particuliers :\n$param = array(\n        \"filename\" =&gt; \"\", /* nom du fichier tel qu'il apparaitra dans le navigateur */\n        \"disposition\" =&gt; \"attachment\", /* attachment : le fichier est telecharge, inline : le fichier est affiche */\n        \"tmp_name\" =&gt; \"\", /* emplacement du fichier dans le serveur */\n        \"content_type\" =&gt; \"\", /* type mime */\n        \"is_reference\" =&gt; false, /* if true, tmp_name contains the handle of the opened file */\n        \"handle\" =&gt; 0;\nsetParam(?array $param);\n\n\nEnvoi d’un fichier\n$view = service (\"FileView\");\nLe fonctionnement est assez semblable à BinaryView, à ceci près que cela ne travaille qu’à partir d’un fichier existant. le type MIME peut également être recherché automatiquement s’il n’est pas indiqué.\n$param = array(\n        \"filename\" =&gt; \"export.txt\", /* nom du fichier tel qu'il apparaitra dans le navigateur */\n        \"disposition\" =&gt; \"attachment\", /* attachment : le fichier est telecharge, inline : le fichier est affiche */\n        \"content_type\" =&gt; \"\", /* type mime */\n        \"tmp_name\" =&gt; \"\", /* Name of the file to send */\n    );\n\n\nRequête Ajax\n$view = service (\"AjaxView\");\nVue utilisée pour répondre à une requête Ajax. Le contenu, qui est fourni par défaut sous forme de tableau (contenu Json possible en positionnant la variable is_json à true, est encodé en html puis transformé en chaîne JSON avant d’être envoyé au navigateur.\n\n\nEnvoi d’un fichier CSV\n$view = service (\"CsvView\");\nCette vue va permettre de générer un fichier CSV à partir d’un tableau ($data[][]). La génération et l’envoi du fichier est réalisé avec la fonction :\nfunction send($filename = \"\", $delimiter = \"\")\nLe nom du fichier peut être généré automatiquement. Le délimiteur peut être le point-virgule, la virgule ou la tabulation (indiquer ). La première ligne d’entête est générée à partir des clés du premier enregistrement du tableau.\n\n\nEnvoi d’un fichier JSON\n$view = service (\"JsonFileView\");\nLa vue génère un fichier dans le navigateur, avec un fonctionnement proche de la vue Ajax. Si les données sont fournies à la classe sous forme de tableau, celles-ci sont encodées en html avant transformation en Json.\n\n\nEnvoi d’un fichier PDF\n$view = service (\"PdfView\");\nTransfert un fichier PDF, soit directement pour être affiché, soit en fichier attaché. Même fonctionnement que la vue FileView.\n\n\nEnvoi un contenu arbitraire au navigateur\n$view = service (\"DisplayView\");\nC’est une vue qui transmet au navigateur un contenu quelconque, sans encodage ni type MIME."
  },
  {
    "objectID": "smarty.html",
    "href": "smarty.html",
    "title": "Affichage des pages web",
    "section": "",
    "text": "Affichage des pages web"
  },
  {
    "objectID": "libraries.html",
    "href": "libraries.html",
    "title": "Bibliothèques",
    "section": "",
    "text": "Bibliothèques"
  },
  {
    "objectID": "installation.html",
    "href": "installation.html",
    "title": "Installation",
    "section": "",
    "text": "L’installation ne peut s’effectuer que dans un dossier vide. L’exemple est donné ici pour une migration vers otolithe2.\n\n\nDans le dossier de niveau supérieur :\ncomposer create-project codeigniter4/appstarter otolithe2  \ncd otolithe2\ncomposer require equinton/ppci\n\n\n\nDifférents fichiers fournis par CodeIgniter doivent être adaptés pour le support de PPCI. Dans le dossier de l’application, à la racine, lancez le script :\nvendor/equinton/ppci/install/install.sh\nLe script va :\n\nrecopier les fichiers nécessaires pour le fonctionnement de l’application dans les différents dossiers :\n\nparamètres dans app/Config\nlibrairies dans app/Libraries (classes par défaut)\ndossier display dans public, et chargement des classes Javascript nécessaires via npm\n\ncréer le dossier writable/temp, et donner les droits en écriture à www-data sur l’ensemble de writable\ngénérer le fichier .env, comprenant les paramètres par défaut d’instanciation\ncréer les clés privée/publique utilisées pour les opérations cryptographiques.\n\n\n\n\n\n\nÉditez le fichier .env, à la racine de l’application, et renseignez impérativement les entrées suivantes :\nCI_ENVIRONMENT = development\napp.baseURL = 'https://myapp.mysociety.com'\n\ndatabase.default.DBDriver = Postgre\ndatabase.default.DBPrefix =\ndatabase.default.port = 5432\ndatabase.default.charset = utf8\ndatabase.default.hostname = localhost\ndatabase.default.database = dbname\ndatabase.default.username = login\ndatabase.default.password = password\ndatabase.default.searchpath = public,app,gacl\n\n\n\nC’est le fichier qui contient les paramètres par défaut de l’application. Il s’agit d’une classe PHP, dont les variables suivantes peuvent être modifiées :\n$dbversion = \"1.0\"; // version de la base de données\n$GACL_aco = \"app\"; // code de l'application dans la gestion des droits\n$version = \"v1.0.0\" ; // Version du logiciel. Elle doit correspondre à une des versions créées dans Github ou Gitlab\n$versionDate = \"01/01/2024\"; //Date de la version\n$APP_help_address =\"\"; //lien vers la création de tickets ou vers la page donnant accès à l'aide\n$copyright = \"\"; //Copyright de l'application\n$APPLI_release = []; // Tableau permettant d'interroger soit Github, soit un serveur Gitlab, pour obtenir les informations concernant la dernière version publiée\n\n\n\n\nConnectez-vous à votre serveur Postgresql avec psql, puis créez votre base de données :\ncreate user applogin inherit login password  'appPassword';\ncreate database app owner applogin;\n\\c app applogin\n\\i vendor/equinton/ppci/install/create.sql\nLe script va créer deux schémas : app pour les tables de l’application, et gacl pour la gestion des droits. Deux tables vont être créées dans le schéma app, nécessaires au fonctionnement de Ppci.\nLa première connexion à l’application utilise le login admin, mot de passe password."
  },
  {
    "objectID": "installation.html#installation-de-codeigniter-et-de-ppci",
    "href": "installation.html#installation-de-codeigniter-et-de-ppci",
    "title": "Installation",
    "section": "",
    "text": "Dans le dossier de niveau supérieur :\ncomposer create-project codeigniter4/appstarter otolithe2  \ncd otolithe2\ncomposer require equinton/ppci"
  },
  {
    "objectID": "installation.html#configuration-du-support-de-ppci",
    "href": "installation.html#configuration-du-support-de-ppci",
    "title": "Installation",
    "section": "",
    "text": "Différents fichiers fournis par CodeIgniter doivent être adaptés pour le support de PPCI. Dans le dossier de l’application, à la racine, lancez le script :\nvendor/equinton/ppci/install/install.sh\nLe script va :\n\nrecopier les fichiers nécessaires pour le fonctionnement de l’application dans les différents dossiers :\n\nparamètres dans app/Config\nlibrairies dans app/Libraries (classes par défaut)\ndossier display dans public, et chargement des classes Javascript nécessaires via npm\n\ncréer le dossier writable/temp, et donner les droits en écriture à www-data sur l’ensemble de writable\ngénérer le fichier .env, comprenant les paramètres par défaut d’instanciation\ncréer les clés privée/publique utilisées pour les opérations cryptographiques."
  },
  {
    "objectID": "installation.html#paramétrage-initial",
    "href": "installation.html#paramétrage-initial",
    "title": "Installation",
    "section": "",
    "text": "Éditez le fichier .env, à la racine de l’application, et renseignez impérativement les entrées suivantes :\nCI_ENVIRONMENT = development\napp.baseURL = 'https://myapp.mysociety.com'\n\ndatabase.default.DBDriver = Postgre\ndatabase.default.DBPrefix =\ndatabase.default.port = 5432\ndatabase.default.charset = utf8\ndatabase.default.hostname = localhost\ndatabase.default.database = dbname\ndatabase.default.username = login\ndatabase.default.password = password\ndatabase.default.searchpath = public,app,gacl\n\n\n\nC’est le fichier qui contient les paramètres par défaut de l’application. Il s’agit d’une classe PHP, dont les variables suivantes peuvent être modifiées :\n$dbversion = \"1.0\"; // version de la base de données\n$GACL_aco = \"app\"; // code de l'application dans la gestion des droits\n$version = \"v1.0.0\" ; // Version du logiciel. Elle doit correspondre à une des versions créées dans Github ou Gitlab\n$versionDate = \"01/01/2024\"; //Date de la version\n$APP_help_address =\"\"; //lien vers la création de tickets ou vers la page donnant accès à l'aide\n$copyright = \"\"; //Copyright de l'application\n$APPLI_release = []; // Tableau permettant d'interroger soit Github, soit un serveur Gitlab, pour obtenir les informations concernant la dernière version publiée"
  },
  {
    "objectID": "installation.html#création-de-la-base-de-données",
    "href": "installation.html#création-de-la-base-de-données",
    "title": "Installation",
    "section": "",
    "text": "Connectez-vous à votre serveur Postgresql avec psql, puis créez votre base de données :\ncreate user applogin inherit login password  'appPassword';\ncreate database app owner applogin;\n\\c app applogin\n\\i vendor/equinton/ppci/install/create.sql\nLe script va créer deux schémas : app pour les tables de l’application, et gacl pour la gestion des droits. Deux tables vont être créées dans le schéma app, nécessaires au fonctionnement de Ppci.\nLa première connexion à l’application utilise le login admin, mot de passe password."
  },
  {
    "objectID": "controllers.html",
    "href": "controllers.html",
    "title": "Contrôleurs",
    "section": "",
    "text": "Contrôleurs"
  },
  {
    "objectID": "principes.html",
    "href": "principes.html",
    "title": "Enchaînement lors de l’appel d’une page",
    "section": "",
    "text": "Vérification du jeton CSRF, présent dans tous les formulaires Smarty\n\n\n\nVérifie l’encodage des caractères transmis depuis le navigateur\n\n\n\nUtilisé pour transformer les adresses de type : index.php?module=nomModule (liens dans les pages web) en route nomModule. Les variables $_GET et $_REQUEST sont stockées en flashdata.\n\n\n\nLance PpciInit:init() :\n\nAvant le démarrage de la session : exécute le script App/Libraries/BeforeSession::index(), pour charger au besoin des classes avant le démarrage de la session\ndémarre la session\nhelper(‘ppci’) : charge les fonctions génériques de PPCI\ninitialise les messages qui ont été transmis avant une redirection\nlit le fichier de paramétrage param.ini (utilisé pour les instances multi-adresses), et met à jour les paramètres dans App, Database et IdentificationConfig\nmet à jour la locale et le fichier des traductions\ninitialise la connexion à la base de données\npurge les logs (table gacl.log). Les logs de plus d’un an sont supprimées\n\n\n\n\n\nrecherche les droits nécessaires dans :\n\nApp/Config/Rights\nPpci/Config/Rights\n\ns’il existe des droits demandés, vérifie si le login existe ou non. S’il n’existe pas, déclenche la procédure de connexion (Ppci/Libraries/Login-&gt;getLogin())\nvérifie que l’utilisateur dispose des droits nécessaires\n\n\n\n\n\nrecherche si le module appelé nécessite le droit admin dans Ppci/Config/Rights\nen cas de module d’administration :\n\nvérifie à quand remonte la dernière identification TOTP ou le dernier appel à un module d’administration\nsi la durée est &gt; 10’ :\n\nsi le compte n’a pas activé le TOTP, affichage de l’écran de création du code TOTP\ndéclenche la saisie du code TOTP\n\n\n\nL’utilisation du TOTP est désactivable (non conseillé en production) avec le paramètre IdentificationConfig\\disableTotpAdmin=1. La durée de la session admin peut être modifiée avec le paramètre IdentificationConfig\\adminSessionDuration=600. La durée est exprimée en secondes.\n\n\n\n\nLes contrôleurs doivent hériter de Ppci/Controllers/PpciController, qui va récupérer depuis FlashData les variables $_GET, $_REQUEST, $_POST et $_SESSION[“lastGet”].\n\n\n\nLes contrôleurs font appel aux librairies, qui peuvent hériter de Ppci\\Libraries\\PpciLibrary. Cette classe propose :\n\ndes paramètres pré-positionnés :\n\nprotected PpciModel $dataClass; : classe permettant de manipuler les informations stockées dans une table\n$this-&gt;message = service('MessagePpci'); : classe permettant d’afficher les messages à l’écran ou de les enregistrer dans les logs du serveur\n$this-&gt;appConfig = config(\"App\"); : paramètres généraux de l’application\n$this-&gt;log = service(\"Log\"); : enregistrement des actions dans la table gacl.log\n\ndes fonctions génériques pour manipuler les données :\n\ndataRead($id, $smartyPage, $idParent = 0) : lit les informations d’un enregistrement dans la classe $dataClass, et génère la vue Smarty\ndataWrite(array $data, bool $isPartOfTransaction = false) : écrit les informations dans la base de données\ndataDelete($id, bool $isPartOfTransaction = false) : supprime un enregistrement\n\n\n\n\n\nL’envoi d’informations au navigateur fait appel à des vues, chacune étant dédiée à un type d’informations (pages web, fichiers pdf, requêtes Ajax, fichiers binaires, etc.). Elles sont disponibles sous forme de services (décrits dans ppci/Config/Services.php), et sont physiquement stockées dans Ppci/Libraries/Views.\nLe détail des vues peut être consulté ici."
  },
  {
    "objectID": "principes.html#filtres",
    "href": "principes.html#filtres",
    "title": "Enchaînement lors de l’appel d’une page",
    "section": "",
    "text": "Vérification du jeton CSRF, présent dans tous les formulaires Smarty\n\n\n\nVérifie l’encodage des caractères transmis depuis le navigateur\n\n\n\nUtilisé pour transformer les adresses de type : index.php?module=nomModule (liens dans les pages web) en route nomModule. Les variables $_GET et $_REQUEST sont stockées en flashdata.\n\n\n\nLance PpciInit:init() :\n\nAvant le démarrage de la session : exécute le script App/Libraries/BeforeSession::index(), pour charger au besoin des classes avant le démarrage de la session\ndémarre la session\nhelper(‘ppci’) : charge les fonctions génériques de PPCI\ninitialise les messages qui ont été transmis avant une redirection\nlit le fichier de paramétrage param.ini (utilisé pour les instances multi-adresses), et met à jour les paramètres dans App, Database et IdentificationConfig\nmet à jour la locale et le fichier des traductions\ninitialise la connexion à la base de données\npurge les logs (table gacl.log). Les logs de plus d’un an sont supprimées\n\n\n\n\n\nrecherche les droits nécessaires dans :\n\nApp/Config/Rights\nPpci/Config/Rights\n\ns’il existe des droits demandés, vérifie si le login existe ou non. S’il n’existe pas, déclenche la procédure de connexion (Ppci/Libraries/Login-&gt;getLogin())\nvérifie que l’utilisateur dispose des droits nécessaires\n\n\n\n\n\nrecherche si le module appelé nécessite le droit admin dans Ppci/Config/Rights\nen cas de module d’administration :\n\nvérifie à quand remonte la dernière identification TOTP ou le dernier appel à un module d’administration\nsi la durée est &gt; 10’ :\n\nsi le compte n’a pas activé le TOTP, affichage de l’écran de création du code TOTP\ndéclenche la saisie du code TOTP\n\n\n\nL’utilisation du TOTP est désactivable (non conseillé en production) avec le paramètre IdentificationConfig\\disableTotpAdmin=1. La durée de la session admin peut être modifiée avec le paramètre IdentificationConfig\\adminSessionDuration=600. La durée est exprimée en secondes."
  },
  {
    "objectID": "principes.html#appel-du-contrôleur",
    "href": "principes.html#appel-du-contrôleur",
    "title": "Enchaînement lors de l’appel d’une page",
    "section": "",
    "text": "Les contrôleurs doivent hériter de Ppci/Controllers/PpciController, qui va récupérer depuis FlashData les variables $_GET, $_REQUEST, $_POST et $_SESSION[“lastGet”]."
  },
  {
    "objectID": "principes.html#appel-des-librairies",
    "href": "principes.html#appel-des-librairies",
    "title": "Enchaînement lors de l’appel d’une page",
    "section": "",
    "text": "Les contrôleurs font appel aux librairies, qui peuvent hériter de Ppci\\Libraries\\PpciLibrary. Cette classe propose :\n\ndes paramètres pré-positionnés :\n\nprotected PpciModel $dataClass; : classe permettant de manipuler les informations stockées dans une table\n$this-&gt;message = service('MessagePpci'); : classe permettant d’afficher les messages à l’écran ou de les enregistrer dans les logs du serveur\n$this-&gt;appConfig = config(\"App\"); : paramètres généraux de l’application\n$this-&gt;log = service(\"Log\"); : enregistrement des actions dans la table gacl.log\n\ndes fonctions génériques pour manipuler les données :\n\ndataRead($id, $smartyPage, $idParent = 0) : lit les informations d’un enregistrement dans la classe $dataClass, et génère la vue Smarty\ndataWrite(array $data, bool $isPartOfTransaction = false) : écrit les informations dans la base de données\ndataDelete($id, bool $isPartOfTransaction = false) : supprime un enregistrement"
  },
  {
    "objectID": "principes.html#les-différentes-vues",
    "href": "principes.html#les-différentes-vues",
    "title": "Enchaînement lors de l’appel d’une page",
    "section": "",
    "text": "L’envoi d’informations au navigateur fait appel à des vues, chacune étant dédiée à un type d’informations (pages web, fichiers pdf, requêtes Ajax, fichiers binaires, etc.). Elles sont disponibles sous forme de services (décrits dans ppci/Config/Services.php), et sont physiquement stockées dans Ppci/Libraries/Views.\nLe détail des vues peut être consulté ici."
  },
  {
    "objectID": "migration.html#mettre-à-jour-la-base-de-données",
    "href": "migration.html#mettre-à-jour-la-base-de-données",
    "title": "Migration depuis PrototypePhp",
    "section": "",
    "text": "Éditez le fichier vendor/equinton/ppci/migration/updatedb.sql, et vérifiez la première ligne (set search_path), en remplaçant app par le nom du schéma contenant les données.\nExécutez ensuite le fichier sql."
  },
  {
    "objectID": "migration.html#mettre-à-niveau-laffichage",
    "href": "migration.html#mettre-à-niveau-laffichage",
    "title": "Migration depuis PrototypePhp",
    "section": "",
    "text": "Éditez le fichier app/Config/menu.xml, et rajoutez les entrées nécessaires.\n\n\n\nRecopiez les modèles Smarty depuis display/templates dans app/Views/templates en conservant l’organisation en sous-dossiers, à l’exception des fichiers à la racine et du sous-dossier framework.\nDans ce dossier, remplacez tous les libellés &lt;/form&gt; par {$csrf}&lt;/form&gt; pour ajouter le jeton CSRF dans les formulaires.\nModifiez également toutes les actions des formulaires, pour qu’ils aient cette forme :\n&lt;form class=\"form-horizontal\" id=\"formName\" method=\"post\" action=\"moduleWrite\"&gt;\n&lt;input type=\"hidden\" name=\"moduleBase\" value=\"module\"&gt;\nLe champ action peut être supprimé. Par contre, le champ moduleBase doit être conservé : il est utilisé pour créer l’action moduleDelete par l’intermédiaire du script javascript dans main_js.tpl. Toutefois, si les modifications ne sont pas réalisées, le script créera automatiquement la bonne action à partir des champs moduleBase et action lors de l’envoi du formulaire."
  },
  {
    "objectID": "migration.html#générer-les-routes-et-les-droits-nécessaires-pour-exécuter-les-modules",
    "href": "migration.html#générer-les-routes-et-les-droits-nécessaires-pour-exécuter-les-modules",
    "title": "Migration depuis PrototypePhp",
    "section": "",
    "text": "Exécutez la commande suivante :\nphp vendor/equinton/ppci/migration/actionsParse.php ../app/param/actions.xml\nLe script va lire l’ancien fichier actions.xml, et va préparer deux contenus :\n\nle premier est destiné à être inséré dans la classe app\\Config\\Rights, et contient la liste des droits nécessaires pour exécuter un module\nle second contient un prototype des routes pour exécuter les modules. Le contenu doit être inséré dans app/Config/Routes.php."
  },
  {
    "objectID": "migration.html#renommer-le-droit-gestion-en-manage",
    "href": "migration.html#renommer-le-droit-gestion-en-manage",
    "title": "Migration depuis PrototypePhp",
    "section": "",
    "text": "Utilisez une fonction de recherche automatique pour remplacer “gestion” par “manage”."
  },
  {
    "objectID": "migration.html#réécriture-des-modèles",
    "href": "migration.html#réécriture-des-modèles",
    "title": "Migration depuis PrototypePhp",
    "section": "",
    "text": "Recopier les fichiers depuis modules/classes vers app/Models.\n\n\nElles peuvent être effectuées par rechercher/remplacer.\n\nremplacer :\n\n&lt;?php par &lt;?php namespace App\\Models;use Ppci\\Models\\PpciModel;, avec sauts de ligne ;\nextends ObjetBDD par extends PpciModel ;\n(public function __construct().*) par public function __construct(), en cochant expression régulière ;\n$this-&gt;colonnes par $this-&gt;fields ;\nfunction ecrire par function write\nfunction lire par function read\nparent::ecrire par parent::write\n(parent::__construct().*) par parent::__construct(), en cochant expression régulière ;\n$this-&gt;id_auto = 0 par $this-&gt;useAutoIncrement = false\nauto_date = 0 par autoFormatDate = false\n\nsupprimer :\n\n$this-&gt;id_auto = 1;\n$param[\"fullDescription\"] = 1;\n\n\n\n\n\n\nrenommer le nom du fichier, par exemple espece.class.php en Espece.php ;\ndans les requêtes SQL, modifier les variables en rajoutant : à la fin : :id doit devenir :id: ;\npour les tables portant des données géographiques (champs avec type=4), modifier les requêtes ou créer les fonctions lire() pour ajouter st_astext() pour les champs concernés ;\nles transformations de dates pour les champs non présents dans la table doivent être réécrites selon ce schéma :\n\n$this-&gt;dateFields[] = \"peche_date\";\n$this-&gt;datetimeFields[] = \"peche_datetime\";"
  },
  {
    "objectID": "migration.html#ajouter-un-filtre-pour-les-opérations-génériques-au-démarrage",
    "href": "migration.html#ajouter-un-filtre-pour-les-opérations-génériques-au-démarrage",
    "title": "Migration depuis PrototypePhp",
    "section": "",
    "text": "Ajouter un filtre pour réaliser les opérations décrites dans modules/common.php ;\nrenseigner le cas échéant la classe App\\Libraries\\Postlogin, pour réaliser les opérations spécifiques après connexion."
  },
  {
    "objectID": "migration.html#réécriture-des-librairies",
    "href": "migration.html#réécriture-des-librairies",
    "title": "Migration depuis PrototypePhp",
    "section": "",
    "text": "Recopier l’ensemble des modules dans app/Libraries. Il faut les transformer en classes.\n\n\nRemplacer :\n\n&lt;?php par :\n\n&lt;?php \nnamespace App\\Libraries;\n\nuse Ppci\\Libraries\\PpciException;\nuse Ppci\\Libraries\\PpciLibrary;\nuse Ppci\\Models\\PpciModel;\n\nclass Xx extends PpciLibrary { \n    /**\n     * @var xx\n     */\n    protected PpciModel $dataclass;\n\n    function __construct()\n    {\n        parent::__construct();\n        $this-&gt;dataClass = new \\App\\Models\\XXX();\n        $keyName = \"xxx_id\";\n        if (isset($_REQUEST[$keyName])) {\n            $this-&gt;id = $_REQUEST[$keyName];\n        }\n    }\n\ndataRead($dataClass, par $this-&gt;dataRead(\ndataWrite($dataClass, par $this-&gt;dataWrite(\ndataDelete($dataClass, par $this-&gt;dataDelete(\ncase \"list\": par function list(){$vue=service('Smarty'); (saut de ligne)\ncase \"display\": par function display(){$vue=service('Smarty'); (saut de ligne)\ncase \"change\": par function change(){$vue=service('Smarty'); (saut de ligne)\ncase \"write\": par function write(){\ncase \"delete\": par function delete(){\ncase \" par function\n\": par () {\nbreak; par } : fermeture des fonctions\n$dataclass par $this-&gt;dataClass\n$id par $this-&gt;id\n$vue par $this-&gt;vue\n$this-&gt;dataDelete($this-&gt;id); par\n\n        try {\n            $this-&gt;dataDelete($this-&gt;id);\n            return $this-&gt;list();\n        } catch (PpciException $e) {\n            return $this-&gt;change();\n        }\n\n$message-&gt; par $this-&gt;message-&gt;\n\net suppression de :\n\nswitch ($t_module[\"param\"]) {\n$bdd, $ObjetBDDParam\n\n\n\n\n\nrenommer le fichier en le commençant par une majuscule\nModifier la fonction __construct() pour charger la bonne classe et le bon identifiant\ndéfinir les vues autres que Smarty dans les fonctions\ndéfinir le retour attendu de chaque fonction :\n\nsoit ajouter la commande return $this-&gt;vue-&gt;send(); pour déclencher l’affichage\nsoit renvoyer vers une des fonctions de la classe : return $this-&gt;display();\nsoit renvoyer vers la page d’accueil : defaultPage();"
  },
  {
    "objectID": "migration.html#ajouter-les-contrôleurs",
    "href": "migration.html#ajouter-les-contrôleurs",
    "title": "Migration depuis PrototypePhp",
    "section": "",
    "text": "Lancez le script :\nphp vendor/equinton/ppci/migration/generateController.php app/Config/Routes.php app/Controllers/\nLe programme va lire les routes définies, puis créer les contrôleurs correspondants, en regroupant les routes par module. Les contrôleurs intègrent lles appels aux fonctions de la librairie correspondante (même nom)."
  },
  {
    "objectID": "migration.html#mettre-à-niveau-le-menu",
    "href": "migration.html#mettre-à-niveau-le-menu",
    "title": "Migration depuis PrototypePhp",
    "section": "",
    "text": "Éditez le fichier app/Config/menu.xml, et rajoutez les entrées nécessaires."
  },
  {
    "objectID": "migration.html#ajouter-les-modèles-smarty",
    "href": "migration.html#ajouter-les-modèles-smarty",
    "title": "Migration depuis PrototypePhp",
    "section": "",
    "text": "Recopiez les modèles Smarty depuis display/templates dans app/Views/templates en conservant l’organisation en sous-dossiers, à l’exception des fichiers à la racine et du sous-dossier framework.\n\n\nDans ce dossier, remplacez tous les libellés (filtre sur *tpl) : - &lt;/form&gt; par {$csrf}&lt;/form&gt; pour ajouter le jeton CSRF dans les formulaires - droits par rights - .gestion par .manage - &lt;script&gt; par &lt;script {$csp_script_nonce}&gt;\nSupprimez\n\nindex.php?module=\n\n\n\n\nReprenez tous les liens (recherchez les balises &lt;a href&gt;) et remplacez le premier & par ?\nModifiez toutes les actions des formulaires, pour qu’ils aient cette forme :\n&lt;form class=\"form-horizontal\" id=\"formName\" method=\"post\" action=\"moduleWrite\"&gt;\n&lt;input type=\"hidden\" name=\"moduleBase\" value=\"module\"&gt;\nLe champ action peut être supprimé. Par contre, le champ moduleBase doit être conservé : il est utilisé pour créer l’action moduleDelete par l’intermédiaire du script javascript dans main_js.tpl. Toutefois, si les modifications ne sont pas réalisées, le script créera automatiquement la bonne action à partir des champs moduleBase et action lors de l’envoi du formulaire."
  },
  {
    "objectID": "migration.html#mettre-à-jour-le-menu",
    "href": "migration.html#mettre-à-jour-le-menu",
    "title": "Migration depuis PrototypePhp",
    "section": "",
    "text": "Éditez le fichier app/Config/menu.xml, pour ajouter les entrées nécessaires à l’application et supprimer celles qui n’ont pas lieu d’être présentes."
  },
  {
    "objectID": "migration.html#mettre-à-niveau-le-readme-et-le-à-propos",
    "href": "migration.html#mettre-à-niveau-le-readme-et-le-à-propos",
    "title": "Migration depuis PrototypePhp",
    "section": "",
    "text": "Éditez les fichiers suivants :\n\napp/Config/news.txt pour les nouveautés en français\napp/Config/newsen.txt pour les nouveautés en anglais\n\nÉditez également les templates suivants :\n\napp/Views/templates/about_fr.tpl\napp/Views/templates/about_en.tpl"
  }
]